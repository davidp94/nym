syntax = "proto3";
import "crypto/coconut/scheme/proto/types.proto";
import "crypto/coconut/scheme/proto/tumblertypes.proto";

package transaction;
option go_package = "0xacab.org/jstuczyn/CoconutGo/tendermint/nymabci/transaction";

message NewAccountRequest {
    // Public Key of the user used to derive account address and validate signature
    bytes PublicKey = 1; 
    // represents some optional credential from an IP if required
    bytes Credential = 2; 
    // Signature on request to confirm its validity + asserts knowledge of private key
    bytes Sig = 3; 
}

message AccountTransferRequest {
    // Used to validate signature + determine source address
    bytes SourcePublicKey = 1;
    // Used to determine target address
    bytes TargetPublicKey = 2; 
    // Amount to be transferred 
    uint64 Amount = 3; 
    // TODO: if this is going to stay past debug, perhaps some field indicating max fee?
    // TODO: if this is going to stay past debug, we need nonce to prevent replay attacks
    // Signature on request to confirm its validitiy
    bytes Sig = 4; 
}

message DepositCoconutCredentialRequest {
    // The actual credential
    coconut.ProtoSignature Sig = 1;
    // The public attributes in credential. Note that pubM[0] = BIG(value)
    repeated bytes PubM = 2;
    // Crypto materials to verify the credential + required NIZK
    coconut.ProtoThetaTumbler Theta = 3;
    // Value of the credential
    int32 Value = 4;
    // Address of the merchant to which the proof is bound
    bytes MerchantAddress = 5;
}

// TODO: remove in next iteration - it was proto msg for testing purposes anyway
// We have defined similar messages before for the grpc provider, however, we can't rely on their definitions 
// in case something changed here (or there) 
message VerifyCoconutCredentialRequest {
    coconut.ProtoSignature Sig = 1;
    repeated bytes PubM = 2;
}

message TransferToHoldingRequest {
    // While Public Key is enough to identify IA and verify signature, attaching ID significantly simplifies the lookup
    // at abci side. If PK was attached, abci would need to compare it with all stored keys until a match was found, now
    // it obtains key in constant time and uses stored key to verify the signature
    uint32 IAID = 1;
    // Which user's funds should be moved
    bytes ClientPublicKey = 2;
    // Amount to move
    int32 Amount = 3;
    // Commitment to attributes the credential, ensures uniqueness of request
    bytes Commitment = 4;
    // To check if the user really wanted the transfer to happen
    // It is done on {ClientPublicKey, Ammount, Commitment}
    bytes ClientSig = 5;
    // To authorise the transfer
    // It is done on {IAID, ClientPublicKey, Ammount, Commitment, ClientSig}
    bytes IASig = 6;
}